export type { Eq } from "fp-ts/lib/Eq";
export * as EqT from "fp-ts/lib/Eq";
export type { Ord } from "fp-ts/lib/Ord";
export * as OrdT from "fp-ts/lib/Ord";
export type { Monoid } from "fp-ts/lib/Monoid";
export * as Monoid_ from "fp-ts/lib/Monoid";
export type { Monad } from "fp-ts/lib/Monad";
export * as Monad_ from "fp-ts/lib/Monad";
export * as RA from "fp-ts/lib/ReadonlyArray";
export * as RM from "fp-ts/lib/ReadonlyMap";
export * as RS from "fp-ts/lib/ReadonlySet";
export * as RR from "fp-ts/lib/ReadonlyRecord";
export * as M from "fp-ts/lib/Map";
export * as S from "fp-ts/lib/Set";
export * as RNEA from "fp-ts/lib/ReadonlyNonEmptyArray";
export * as NEA from "fp-ts/lib/NonEmptyArray";
export type { ReadonlyRecord } from "fp-ts/lib/ReadonlyRecord";
export type { ReadonlyNonEmptyArray } from "fp-ts/lib/ReadonlyNonEmptyArray";
export type { NonEmptyArray } from "fp-ts/lib/NonEmptyArray";
export * as O from "fp-ts/lib/Option";
export type { Option } from "fp-ts/lib/Option";
export * as E from "fp-ts/lib/Either";
export type { Either } from "fp-ts/lib/Either";
export * as I from "fp-ts/lib/IO";
export type { IO } from "fp-ts/lib/IO";
export { pipe } from "fp-ts/lib/pipeable";
export { flow, identity, constant } from "fp-ts/lib/function";
export type {
  Endomorphism,
  Refinement,
  Predicate,
  Lazy,
} from "fp-ts/lib/function";
